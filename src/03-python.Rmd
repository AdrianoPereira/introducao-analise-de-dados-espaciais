# Python `r emo::ji("sparkles")`

```{r, echo=FALSE}
# Estes comandos não devem ser executados em seu terminal
library(reticulate) 
use_python("venv/bin/python3")
```

```{python, echo = FALSE}
# Carrega por padrão, mesmo repetindo no código =D
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
```

Python é uma linguagem de programação versátil, multiparadigma, que permite aos desenvolvedores criar rápidas soluções para seus problemas sem grandes preocupações com a sintaxe e formas de uso da linguagem. 

Por ser uma linguagem de aplicações gerais, 


Essas características trouxeram para Python uma comunidade extremamente ativa e acolhedora, o que gerou uma infinidade de bibliotecas para a 

Um ponto forte da linguagem é a maturidade de seu ecossitema, que através de milhares de pacotes disponiblizados por uma comunidade incrível, faz com que a linguagem possa ser fácilmente aplicada nos mais variados contextos.

Nesta seção do material de introdução à análise de dados espaciais vamos discutir uma das várias soluções existentes para a manipulação de dados espaciais, o `GeoPandas`.

Para começarmos, vamos falar um pouco sobre o `Pandas` a biblioteca utilizada como base para a criação do `GeoPandas`.

Como citado anteriormente, Python é uma linguagem de programação que não foi criada com nenhum propósito específico, assim como acontece com linguagens como R e Julia, que desde sua criação tiveram o foco em uma área específica.

Desta forma, não podemos esperar que por padrão a linguagem disponibilize funcionalidades para a leitura e escrita de dados, nos mais variados formatos, ou mesmo diferentes métodos para análise de tais dados. É neste contexto que o pandas é inserido.

<!-- Citar aqui em cima que, as bibliotecas foram criadas por conta da característica geral da linguagem, e que sua facilidade atraiu utilizados das mais variadas áreas -->

<!-- Nesta seção, primeiro será feito a introdução ao pandas, biblioteca base utilizada pelo GeoPandas para a realização de toda a manipulação dos dados  -->

<!-- ToDo: Inserir isto aqui na intro para ajudar que está começando -->
<!-- Para mais informações para a utilização do Pandas, consulte o [material do curso de introdução à análise de dados](https://dataat.github.io/introducao-analise-de-dados/introducao-ao-python.html) -->

## Pandas `r emo::ji("panda")`

Com a necessidade de facilitar todo o processo de análise de dados, através de uma linguagem simples e amigável, a comunidade Python criou o Pandas, uma biblioteca que disponibiliza métodos de alto nível para a manipulação, processamento e análise dos mais variados tipos de dados.

Através dos métodos desta biblioteca é possível aplicar todo o ciclo de análise de dados, este indo desde a coleta até o processamento e análise. Para realizar tais atividades, o pandas disponibiliza diversas estruturas de dados, sendo as `Series` e os `DataFrames` as principais.

Cada uma dessas estruturas de dados, trata especificamente de uma forma de realizar a abstração do formato dos dados em código, isto faz com que seja necessário o entendimento das principais diferentes entre cada uma delas, para que seja possível realizar sua correta aplicação. Vamos buscar comparar cada uma dessas estruturas para entender suas diferenças.

As `Series` são estruturas de dados unidimensionais, possuindo apenas uma dimensão que pode ser manipulada, tal dimensão sendo chamada de índice. Já os `DataFrames` apresentam duas dimensões para a manipulação.

Estas características, na prática, indicam que, as `Series` apenas representar vetores, enquanto os `DataFrames` podem representar matrizes de N-Dimensões. Para esta ideia ficar clara, vejamos a Figura abaixo.

<center>
<div style="width:500px; height:400px">
![](res/3_python/series_vs_dataframe.svg)
</div>
</center>

Perceba que, as `Series` possuem o campo para o armazenamento dos dados (Representado em Azul), e o índice (Represetnado em roxo), não podendendo ser adicionado nenhum outro campo, isto faz com que, todos os dados tenham de ser armazenados em apenas uma coluna, em várias linhas.

Para o `DataFrame` o cenário apresentado na Figura é diferente, além dos índices, há também as colunas (Representada em vermelho), o que permite que dentro desta estrutura existam não só um conjunto de linhas, como as `Series` mas sim um conjunto de colunas, onde cada uma dessas possuem várias linhas. Na prática o que fica subentendido é que, os `DataFrames` são um conjunto de `Series`.

<center>
![](res/3_python/relacoes_pandas.svg)
</center>

Isto ocorre já que, cada uma das colunas criadas dentro do `DataFrame` são `Series`, o que acaba gerando um efeito muito interessante na API do Pandas, boa parte dos métodos disponíveis para as `Series` também estão presentes nos `DataFrames`. Vamos ver alguns exemplos em código para fixar a diferença entre essas duas estruturas de dados.

### Manipulação de dados

Vamos começar criando uma `Series`.

```{python}
import pandas as pd

sr = pd.Series([1, 2, 3, 4, 5])
```

Pronto! Acabamos de criar uma `Series` com uma lista de valores, vejamos como ela está sendo representada.

```{python}
print(sr)
```

A representação está da mesma forma que vimos antes. Vamos agora fazer uma pequena manipulação dos dados, para isto, utilizaremos os métodos `loc` e `iloc` disponíveis dentro do objeto `Series` gerado, onde o método `loc` busca o índice com o nome inserido e o `iloc` busca o índice com a posição inserida. A assinatura de cada um dos métodos está descrita abaixo. Lembre-se que este método está presente tanto na classe `Series` como na classe `DataFrame`.

| DataFrame        | Series     |     
| ------------- |:-------------:|
| .loc[linha, coluna]  | .loc[linha] |
| .iloc[linha] | .iloc[linha] |


Antes de fazermos o teste destes métodos, vamos alterar o índice da nossa `Series`.

```{python}
# Vamos visualizar o índice
print(sr.index)
```

O atributo `index` devolve os elementos que estão no índice, para fazer sua mudança, basta realizar uma atribuição, veja.


```{python}
sr.index = ["um", "dois", "tres", "quatro", "cinco"]

print(sr.index)
```

Fizemos esta mudança, para que cada um dos métodos `loc` e `iloc` seja mais simples de entender. Certo, vamos começar buscando a linha que tenha o nome `dois`.

```{python}
print(sr.loc["dois"])
```

Agora vamos buscar a linha que está na posição dois.

```{python}
print(sr.iloc[1]) # Lembre-se, o Python começa a contar no zero =D
```

Percebeu? Temos o mesmo resultado, muito interessante não ? Além disso ainda posso aplicar filtros sob os dados,utilizando o conceito de `indexação booleana`, onde através de um vetor de `VERDADEIRO` e `FALSO` é possível selecionar as linhas.

Vamos buscar somente os valores que são acima de cinco.

```{python}
print(sr[sr > 5])
```

> Dica: O que ocorre nesta parte é, dentro das chaves de `sr` (sr[]) é passado a expressão `sr > 5` que devolve uma lista de verdadeiros e falsos, fazendo assim o filtro.

Muito interessante! Mas até aqui trabalhamos com apenas uma dimesão, vamos tentar acrescentar mais uma dimesão a estes dados.

```{python}
matriz = [
  [1, 2, 3], [4, 5, 6]
]
```

Criei uma matriz, esta que é representada por uma lista de listas. Vamos tentar criar uma `Series` com esta matriz.

```{python}
sr = pd.Series(matriz)

print(sr)
```

Eita! Perceba que, em cada linha há uma lista de valores, o que é ruim! Já que a manipulação fica difícil (Tenta fazer uma indexação booleana, vai falhar `r emo::ji("cry")`).

Para este caso, existem os `DataFrames`! Vamos começar criando um com a mesma matriz gerada anteriormente.

```{python}
df = pd.DataFrame(matriz)

print(df)
```

Opa! Agora o cenário é outro, conseguimos colocar cada um dos valores em seu devido lugar. Perceba que a representação mudou bastante, aqui temos várias colunas de dados, e mesmo assim, todos os métodos já apresentados até aqui funcionam. Vai lá, tenta!

Uma coisa importante sobre os `DataFrames` são suas colunas, para acessar elas podemos fazer da seguinte forma.

```{python}
print(df[0])
```

Viu! Estamos acessando a primeira coluna, se fizermos a mesma coisa, com a segunda também vai funcionar (Tenta inserir o número 1, para você ver o que acontece).

> Dica: Ao fazer df[0], estamos buscando o "nome" da coluna, e não sua posição

Da mesma forma que eu podemos recuperar o índice com o atributo `index` podemos recuperar as colunas com o atributo `columns`

```{python}
print(df.columns)
```

Para fazer a mudança dos nomes de cada coluna a mesma regra do `index` é válida.

```{python}
df.columns = ["col1", "col2", "col3"]

print(df.columns)
```

Vamos recuperar a primeira coluna novamente

```{python}
print(df["col1"])
```

Assim, fica mais fácil entender que, quando se trata de colunas, estamos buscando os nomes, e não simplesmente as posições.

Bom, agora que já entendemos toda a utilização básica do Pandas, vamos começar a falar um pouco sobre o GeoPandas `r emo::ji("purple_heart")`

## GeoPandas `r emo::ji("earth")``r emo::ji("panda")`

Com o entendimento do que é a biblioteca Pandas, suas estruturas de dados e principais características, o estudo do GeoPandas pode ser iniciado. Mas o que é o GeoPandas ?

> GeoPandas é um projeto open-source que busca facilitar o trabalho com dados vetoriais geoespaciais em Python, para isto, tem como base as estruturas de dados do Pandas

Desta forma, a ideia básica por trás do GeoPandas é adicionar o suporte a manipulação de dados espaciais as estruturas de dados do Pandas, e com isto prover formas de manipulação simples e direta aos dados espaciais.

Para fazer isto, o GeoPandas utiliza estruturas de dados geométricas implementadas pela biblioteca [Shapely](https://shapely.readthedocs.io/en/stable/manual.html) dentro das `Series` e dos `DataFrames`. Ao fazer esta adição duas estruturas de dados básicas do GeoPandas são disponibilizadas, as `GeoSeries` e os `GeoDataFrames`.

Este conceito pode ser melhor entendido com a observação da Figura abaixo.

<center>
![](res/3_python/relacoes_pandas_e_geopandas.svg)
</center>

Perceba que, há a mesma estrutura que foi apresentada na seção anterior, com as geometrias sendo o diferencial nas estruturas de dados.

Na prática o que ocorre é, todas as formas de manipulação geométricas, que como citadas são implementadas com o Shapely, são implementadas em uma classe `GeoPandasBase` que é extendida pelas `GeoSeries` e `GeoDataFrames`, da mesma forma, essas também extendem as estruturas de dados equivalentes do Pandas, veja a Figura abaixo.

<center>
![](res/3_python/geopandas_classes.svg)
</center>

Como a `GeoSeries` e os `GeoDataFrames` são especializações diretas das `Series` e dos `DataFrames` as mesmas características são mantidas, onde, respectivamente, um armazena apenas uma coluna de valores, tendo uma dimensão de manipulação e o outro armazena diversas colunas com duas dimensões de manipulação, da mesma forma como apresentado na seção anterior.

Para fixar o funcionamento de cada uma dessas estruturas, vamos fazer alguns testes com a API do GeoPandas. 

### GeoSeries e GeoDataFrames

Para começar os testes, vamos importar a biblioteca de geometrias, `Shapely` e o GeoPandas.

```{python}
import shapely
import geopandas as gpd
```

Agora, vamos criar uma `GeoSeries`.

```{python}
gsr = gpd.GeoSeries([
  shapely.geometry.Point(1, 1)
])
```

> Dica: A geometria criada não possui qualquer tipo de referência espacial, portanto representa apenas um ponto no plano cartesiano.

Veja que acabamos de criar uma `GeoSeries` que armazena uma geometria de ponto, vamos visualizar o objeto criado.

```{python}
print(gsr)
```

A forma é exatamente a mesma de uma `Series`. Vamos criar um novo objeto com mais geometrias inseridas.

```{python}
gsr = gpd.GeoSeries([
  shapely.geometry.Point(1, 1),
  shapely.geometry.Point(2, 2),
  shapely.geometry.Point(4, 3)
])

print(gsr)
```

Caso eu queira visualizar não só a tabela, mas sim a representação das geometrias criadas no espaço, é possível utilizar o método `plot`.

```
gsr.plot()
```
<center>
```{python, echo = FALSE}
gsr.plot(figsize=(6, 6))
plt.show()
```
</center>

Mas as `GeoSeries` podem ser limitadas em alguns casos, porque digo isto ? Vamos supor que para a realização de um estudo seja necessário não só a geolocalização, ou a representação geométrica no espaço, mas também características do ambiente, qualquer tipo de informação que não a espacial. Nestes casos podemos utilizar os `GeoDataFrames` que além de colunas de geometria permitem o armazenamento de outras informações, isto por permitir multiplas colunas, vamos criar um objeto para fazer testes.

```{python}
gdf = gpd.GeoDataFrame({
  'atributo_a': [10, 11, 12],
  'geometria': [
    shapely.geometry.Point(1, 1),
    shapely.geometry.Point(2, 2),
    shapely.geometry.Point(4, 3)
  ]
})
```

Vamos visualizar como ficou o resultado.

```{python}
print(gdf)
```

Agora as geometrias passam a ser vinculadas com outros valores, o que pode ser muito útil em vários cenários. Até aqui criamos nossas próprias geometrias, sem uma representação do mundo real ou algo assim, vamos agora começar com dados que possuam esta representação, para isto, vamos aprender a realizar a manipulação de leitura e escrita de dados com o GeoPandas.

### Leitura e escrita de dados

<!--
  Falar do Fiona
  
  Aqui deixar claro que, a ideia do pandas é trabalhar com dados vetoriais, ou, em caso de dados
  matriciais, que sua representação seja simplificada em tabelas, o que pode trazer certo desempenho... (Deixar claro para o pessoal não achar que a leitura de imagens por exemplo possa ser feito nessa lib.)
-->

<!-- Explicar aqui que além da manipulação o GeoPandas ajuda na leitura e escrita
da mesma forma como é feito pelo pandas (Inclusive com a mesma facilidade).

  O geopandas pode fazer a leitura dos seguintes formados de dados: A, B, C.
  
  Para entendermos melhor como funciona cada um destes dados, veja:
  
   - Exemplo de consumo de dados Shapefile A
   - Exemplo de consumo de dados Shapefile B;
   - Exemplo de consumo de dados Shapefile C;
-->

### Manipulação geométrica

<!--
  Aqui cite tudo o que o pandas pode fazer, porém mostre exemplos apenas do Buffer e do envelope.
  Pq o resto acaba sendo bem específico e pode não ter tanta aplicação para os alunos do curso em um
  primeiro momento.
-->

### Seleção e filtro de dados

<!--
  Na seção do Pandas explique os filtro convencionais de busca de dados, pq nesta parte conseguimos fazer um gancho e dizer: "Veja, além de toda a forma de busca do pandas, o geopandas ainda consegue fazer indexação levando em consideração a localização no espaço dos dados que estão salvos".
-->

### Manipulação de projeções

<!--
  Falar brevemente como o GeoPandas faz estas manipulações.
-->
